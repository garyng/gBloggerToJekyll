玩网游的自动寻路是不是很帅？网上有一些破解迷宫的程序，是不是很帅？<br />
给定一个有多个节点的路径的图形，A*算法（读做A星算法）是求从一点到另一点的最低成本的算法（也就是最短的路径，当然这里“最短”是相对的）。<br />
这篇文章非常基本，专门给像我这种刚刚入门的新手。<br />
<br />
<h1 align="center">
【区域分割】</h1>
假设说我们有一副图：<br />
<a href="http://lh3.ggpht.com/-MZxO64-CDqw/UnoNLxEZXlI/AAAAAAAAFTA/I1FsyaHjX5E/s1600-h/image%25255B2%25255D.png"><img alt="image" border="0" height="344" src="http://lh5.ggpht.com/-I6w_vW2qVlo/UnoNMv4kQEI/AAAAAAAAFTI/TtpzWYlahpg/image_thumb.png?imgmax=800" style="border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline;" title="image" width="731" /></a> <br />
<br />
现在有一个人在绿色的地方<br />
然后红色的地方是墙壁（不能通过）<br />
然后那个人要一最短的时间从绿色的地方 走到 紫色的地方<br />
<br />
为了方便，我们把开始的地方（绿色部分）取名为A点<br />
结束（紫色部分）为B点<br />
<br />
问题简化为：找出从A点直B点最短的路径。<br />
那要怎么搜索呢？<br />
<br />
看过地板上的地砖么？地砖是不是把整个地板分成了一格一格的？<br />
所以我们把我们的地图（就叫做地图吧）分割成一格一格的，像这样：<br />
<a href="http://lh5.ggpht.com/-wllsvjX2PK0/UnoNNDFGnAI/AAAAAAAAFTQ/2jRyQzOGY-U/s1600-h/image%25255B5%25255D.png"><img alt="image" border="0" height="344" src="http://lh3.ggpht.com/-tcGbULQFluc/UnoNN_49v7I/AAAAAAAAFTY/dPIeLWhv0q4/image_thumb%25255B1%25255D.png?imgmax=800" style="border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline;" title="image" width="731" /></a> <br />
<br />
那样是不是方便多了？<br />
这些一格一格的“地砖”叫做“节点”，分割搜索区域是寻路简单化，而且可以直接将其储存进一个二维数组内。<br />
寻路算法就是找出能从A到B的方格，然后这些方格就组成了我们所需要的“路径”<br />
找出路径之后，那个人就能从A点走到B点了（废话..）<br />
你当然可以把整个地图分成不同的形状：三角形、正方形、矩形等等<br />
但是为了方便起见，在这里我们就用矩形吧！<br />
<br />
<h1 align="center">
【开始搜索】</h1>
把搜索区域化成一堆节点后，就是开始搜索了！<br />
要如何搜索？<br />
1、从A点开始，把A点加入一个“开放列表”<br />
开放列表中的方格可能会是待会儿会经过的路径，也可能不是<br />
当前的开放列表之中只有A点一个<br />
2、检查A点相邻的方格，让后将它们也一起加入开放列表之中（相邻的都要加入，别管那个节点能不能通过）<br />
对于每一个相邻的方格，将A点设为他们的“父亲”，这点很重要<br />
3、从开放列表去掉A，加入“封闭列表”内<br />
<br />
最后得到的是这样：<br />
<a href="http://lh3.ggpht.com/-rJrD8C1QfDE/UnoNOQh_OcI/AAAAAAAAFTg/Hmu7aZiDBis/s1600-h/image%25255B8%25255D.png"><img alt="image" border="0" height="390" src="http://lh4.ggpht.com/-FPawV5Ljweg/UnoNO6FmYBI/AAAAAAAAFTo/_W4GBrKebF0/image_thumb%25255B2%25255D.png?imgmax=800" style="border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline;" title="image" width="743" /></a> <br />
<br />
黄色框的是在“开放列表”之中<br />
白色框的是在“封闭列表”之中<br />
<br />
4、接下来就是从开放列表之中选一个相邻的方格，然后在重复步骤<br />
那么，要选哪一个方格呢？<br />
选F最小的那个！<br />
<br />
<h1 align="center">
【计算F值】</h1>
F = G + H<br />
F值决定那个方格会成为路径<br />
这里的：<br />
<blockquote>
G = 从A点开始到当前的点所需要的移动开销<br />
H = 从当前方格到目的地方格的估计移动开销。</blockquote>
<h2>
【计算G值】</h2>
G值是从A点开始到当前的点所需要的开销<br />
当前的点就是那些相邻的方格<br />
在这里：<br />
<blockquote>
水平/垂直移动的开销 = 10<br />
对角线移动的开销 = 14</blockquote>
怎么算出来的？<br />
很简单，就是一个边长为1的直角三角形呗！<br />
<a href="http://lh4.ggpht.com/-UuyK00_OFFA/UnoNPqIjGII/AAAAAAAAFTs/p6Sdm656gdQ/s1600-h/image%25255B11%25255D.png"><img alt="image" border="0" height="305" src="http://lh6.ggpht.com/-Lg-AgaVdGCs/UnoNQNUvN8I/AAAAAAAAFT4/obTSxdSDyDk/image_thumb%25255B3%25255D.png?imgmax=800" style="border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline;" title="image" width="322" /></a> <br />
只是在这里全部都乘10，这会让电脑轻松些<br />
<br />
<h2>
【计算H值】</h2>
有很多方法可以估算H值<br />
这里用的叫做 Manhattan 方法，它并不考虑路途中的任何障碍物<br />
<blockquote>
H = 当前的点与目的地点的垂直距离 + 当前的点与目的地点的水平距离</blockquote>
像这样：<br />
<a href="http://lh3.ggpht.com/-KX2V6pmt-Yk/UnoNQtlusrI/AAAAAAAAFUA/TzhzvJHg_3Q/s1600-h/image%25255B17%25255D.png"><img alt="image" border="0" height="231" src="http://lh5.ggpht.com/-qRAwtReK8FU/UnoNRXUtjMI/AAAAAAAAFUE/GAN7AQwwOZg/image_thumb%25255B5%25255D.png?imgmax=800" style="border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline;" title="image" width="438" /></a> <br />
所以F = G + H<br />
<br />
这里左上角是F<br />
左下角是G<br />
右下角是H<br />
<br />
<a href="http://lh3.ggpht.com/-NbDxppl-qtU/UnoNR8eNI2I/AAAAAAAAFUQ/mIBTEWl-jgw/s1600-h/image%25255B20%25255D.png"><img alt="image" border="0" height="421" src="http://lh4.ggpht.com/-41GeV9-puWA/UnoNSmZTqiI/AAAAAAAAFUY/Nb3svLBU4kE/image_thumb%25255B6%25255D.png?imgmax=800" style="border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline;" title="image" width="777" /></a> <br />
<br />
<h1 align="center">
【继续搜索】</h1>
1、我们从开放列表之中选择拥有最小F值的方格<br />
2、从开放列表之中将其移除，加入到封闭列表之中<br />
3、检测该方格所有的相邻方格，计算F值。<br />
<blockquote>
1、忽略那些已经在封闭列表之中的方格<br />
2、如果有相邻方格在开放列表之中，依旧计算其F值，然后与之前计算过的F值比较，如果当前的F值小，覆盖之前计算出来的F值，并将其的父方格设为当前方格</blockquote>
4、将相邻的方格的父方格设置为当前方格<br />
来看看例子<br />
<br />
在这里坐标（2，2）的方格拥有最小的F值（40）<br />
所以我们选择它，然后将其放入封闭列表之中<br />
<a href="http://lh5.ggpht.com/-2vL2kfdGQ1s/UnoNTFei4SI/AAAAAAAAFUg/qhtYfHTy8ok/s1600-h/image%25255B23%25255D.png"><img alt="image" border="0" height="421" src="http://lh4.ggpht.com/-oh3SsAInd3U/UnoNT2XmefI/AAAAAAAAFUo/tVudTHJ-3a8/image_thumb%25255B7%25255D.png?imgmax=800" style="border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline;" title="image" width="777" /></a> <br />
现在它的右边、右上角、右下角是墙，左边的起始方格已经在封闭列表之中了，所以忽略<br />
现在只剩下4个待检测的方格——左上角、左下角、上、下<br />
那些方格都已经在开放列表之中了<br />
所以我们计算然后比较他们的F值<br />
先忽略之前计算过的F值<br />
我们得到的F值是：<br />
（注意G值的变化）<br />
<a href="http://lh4.ggpht.com/-LJIifT0WcNc/UnoNUklTuaI/AAAAAAAAFUw/yi2EMn2y76A/s1600-h/image%25255B29%25255D.png"><img alt="image" border="0" height="218" src="http://lh4.ggpht.com/-jmftuVDcLsI/UnoNVJotw8I/AAAAAAAAFU4/gKtYL-YV3mE/image_thumb%25255B9%25255D.png?imgmax=800" style="border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline;" title="image" width="314" /></a> <br />
可是他们都比之前算出来的F值大<br />
所以我们都忽略现在计算出来的F值，用回之前计算的F值<br />
<a href="http://lh5.ggpht.com/-2vL2kfdGQ1s/UnoNTFei4SI/AAAAAAAAFUg/qhtYfHTy8ok/s1600-h/image%25255B23%25255D.png"><img alt="image" border="0" height="421" src="http://lh4.ggpht.com/-oh3SsAInd3U/UnoNT2XmefI/AAAAAAAAFUo/tVudTHJ-3a8/image_thumb%25255B7%25255D.png?imgmax=800" style="border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline;" title="image" width="777" /></a> <br />
<br />
现在我们的开放列表只剩下7个方格了<br />
有最小F值的方格有两个，但是选那个都没有关系<br />
我们就选（2，3）吧！<br />
从开放列表中移除，加入封闭列表之中<br />
<a href="http://lh5.ggpht.com/-grUmHUmwRPM/UnoNV3Wr5FI/AAAAAAAAFVA/0Ajgijbc5lM/s1600-h/image%25255B32%25255D.png"><img alt="image" border="0" height="404" src="http://lh4.ggpht.com/-9fTT7OZ0GYg/UnoNWb3UzzI/AAAAAAAAFVI/4uvganHMqPA/image_thumb%25255B10%25255D.png?imgmax=800" style="border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline;" title="image" width="758" /></a> <br />
<br />
然后计算相邻方格的F值<br />
加入开放列表，比较F值，然后设置父方格：<br />
<a href="http://lh4.ggpht.com/-n74t71SEdgI/UnoNW1wCsBI/AAAAAAAAFVQ/E9ZnSPQ0NZU/s1600-h/image%25255B35%25255D.png"><img alt="image" border="0" height="404" src="http://lh6.ggpht.com/-ea62nmuXJE4/UnoNXmghuDI/AAAAAAAAFVY/lME40mJ6-jI/image_thumb%25255B11%25255D.png?imgmax=800" style="border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline;" title="image" width="758" /></a> <br />
发现到没？<br />
我没有直接检测墙下的方格（3，4）<br />
这事能设定的<br />
如果你不要有人能直角穿过墙角的话，当遇到墙壁时，就不要检测对角的方格<br />
那个方格留给别个方格<br />
<br />
然后搜索继续：<br />
<a href="http://lh6.ggpht.com/-o3WpZRmQPQI/UnoNYRJSqsI/AAAAAAAAFVg/htwdFVwGrLM/s1600-h/image%25255B41%25255D.png"><img alt="image" border="0" height="404" src="http://lh6.ggpht.com/-PCmo5dUURZ0/UnoNZEHXs2I/AAAAAAAAFVo/tarPPZVA_Uw/image_thumb%25255B13%25255D.png?imgmax=800" style="border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline;" title="image" width="758" /></a> <br />
有没有发现到（1，4）的方格的父方格变化了？<br />
本来是（2，3）的<br />
<a href="http://lh3.ggpht.com/--9hndVukh9o/UnoNZifeIrI/AAAAAAAAFVw/qLftugZrbOQ/s1600-h/image%25255B47%25255D.png"><img alt="image" border="0" height="198" src="http://lh3.ggpht.com/-9GJ3PDuf-MY/UnoNaVQj-cI/AAAAAAAAFV4/Epzp9cJnzgg/image_thumb%25255B15%25255D.png?imgmax=800" style="border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline;" title="image" width="290" /></a> <br />
变成了（1，3）<br />
<a href="http://lh6.ggpht.com/-n_MIJI3eSzQ/UnoNa_fsR1I/AAAAAAAAFWA/6v2KEwS1KDI/s1600-h/image%25255B50%25255D.png"><img alt="image" border="0" height="202" src="http://lh6.ggpht.com/-QOVIEgppPuA/UnoNbjsR1YI/AAAAAAAAFWI/-7iQglCy3nw/image_thumb%25255B16%25255D.png?imgmax=800" style="border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline;" title="image" width="298" /></a> <br />
原因是F值更加小了 （之前的 88 和 80）<br />
很明显的路径（1，2）-&gt; （2，3） –&gt; （1，4）比路径（1，2）-&gt; （1，3）-&gt;（1，4）更长<br />
我们要最短的路径嘛！<br />
<br />
继续搜索：<br />
接下来就不详解了<br />
步骤都一样的<br />
<a href="http://lh5.ggpht.com/-KZuA91vPpB0/UnoNcXf9LsI/AAAAAAAAFWQ/eTbdHCm2H7k/s1600-h/image%25255B53%25255D.png"><img alt="image" border="0" height="405" src="http://lh5.ggpht.com/-K89PXlocQvA/UnoNc73n1mI/AAAAAAAAFWY/LVJ2dz4I6Ks/image_thumb%25255B17%25255D.png?imgmax=800" style="border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline;" title="image" width="757" /></a> <br />
<a href="http://lh6.ggpht.com/-HAUqXczXJ_I/UnoNdid57eI/AAAAAAAAFWg/4x7suqgxRcQ/s1600-h/image%25255B56%25255D.png"><img alt="image" border="0" height="405" src="http://lh5.ggpht.com/-GYydnop5_4c/UnoNeVd1xQI/AAAAAAAAFWo/INPe-XDo42E/image_thumb%25255B18%25255D.png?imgmax=800" style="border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline;" title="image" width="757" /></a> <br />
<a href="http://lh5.ggpht.com/-S-EXoik4MGc/UnoNeyovXeI/AAAAAAAAFWw/HD7836DjpVo/s1600-h/image%25255B59%25255D.png"><img alt="image" border="0" height="405" src="http://lh3.ggpht.com/-WL6hi8QfkGA/UnoNfnKCvKI/AAAAAAAAFW4/LypCz6t2zeg/image_thumb%25255B19%25255D.png?imgmax=800" style="border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline;" title="image" width="757" /></a> <br />
<a href="http://lh3.ggpht.com/-oCOUpgW09Bo/UnoNgYNvRYI/AAAAAAAAFXA/24zl7SODhBk/s1600-h/image%25255B65%25255D.png"><img alt="image" border="0" height="405" src="http://lh3.ggpht.com/-vT3BPIdi4Pk/UnoNhCeQlJI/AAAAAAAAFXI/armBihGzwgM/image_thumb%25255B21%25255D.png?imgmax=800" style="border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline;" title="image" width="757" /></a> <br />
<a href="http://lh3.ggpht.com/-7tA_KBx8T8Q/UnoNh9q5bUI/AAAAAAAAFXQ/Di_XcxPD4Wc/s1600-h/image%25255B71%25255D.png"><img alt="image" border="0" height="405" src="http://lh4.ggpht.com/-getxiF5eXPA/UnoNiTOgb1I/AAAAAAAAFXY/_3PC_ra5xO0/image_thumb%25255B23%25255D.png?imgmax=800" style="border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline;" title="image" width="757" /></a> <br />
到这里<br />
目的地方格已经有父方格了<br />
如何找出路径呢？<br />
只要中目的地方格沿着走到下一个父方格，一直到起始方格就好了！<br />
先这样：<br />
<a href="http://lh5.ggpht.com/-w6pG0VAOgOw/UnoNjcYJ_GI/AAAAAAAAFXg/gPjOGofWi1I/s1600-h/image%25255B74%25255D.png"><img alt="image" border="0" height="405" src="http://lh4.ggpht.com/-jqbqf4CV_B8/UnoNkK3Fx5I/AAAAAAAAFXo/w98vaVAR-Ws/image_thumb%25255B24%25255D.png?imgmax=800" style="border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline;" title="image" width="757" /></a> <br />
<br />
<h1 align="center">
【C#实现】</h1>
整个C#实现A* 寻路算法的代码我推到GitHub 上去了：<br />
<a href="https://github.com/garyng/PathFinding"><span style="font-size: medium;">https://github.com/garyng/PathFinding</span></a><br />
这里的代码仅供参考<br />
不一定是最好、最优的<br />
这个是Node class<br />
代表每一个节点<br />
<pre class="brush: csharp">using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;

namespace PathFinding
{
    public class Node
    {

        private int _h;
        private const int _count = 8; //properties count - for indexing
        private Point _pos;
        private Node _parent;
        private int _g;
        private Node _dLeft;
        private int _f;
        private Node _uLeft;
        private Node _dRight;
        private Node _uRight;
        private Node _down;
        private Node _up;
        private Node _right;
        private Node _left;
        private bool _isWall;
        
        public Node()
        {
            this.Left = null;
            this.Right = null;
            this.Down = null;
            this.Up = null;
            this.URight = null;
            this.ULeft = null;
            this.DLeft = null;
            this.DRight = null;
        }

        public Node(Node left, Node right, Node down, Node up, Node uRight, Node dRight, Node uLeft, Node dLeft)
        {
            this.Left = left;
            this.Right = right;
            this.Down = down;
            this.Up = up;
            this.URight = uRight;
            this.ULeft = uLeft;
            this.DLeft = dLeft;
            this.DRight = dRight;
        }

        private Node SwitchNodeProp(int index, Node value = null)
        {
            switch (index)
            {
                case 0:
                    //Up
                    return ReturnNodeProp(ref _up,value);
                case 1:
                    //URight
                    return ReturnNodeProp(ref _uRight, value);
                case 2:
                    //Right
                    return ReturnNodeProp(ref _right, value);
                case 3:
                    //DRight
                    return ReturnNodeProp(ref _dRight, value);
                case 4:
                    //Down
                    return ReturnNodeProp(ref _down, value);
                case 5:
                    //DLeft
                    return ReturnNodeProp(ref _dLeft, value);
                case 6:
                    //Left
                    return ReturnNodeProp(ref _left, value);
                case 7:
                    //ULeft
                    return ReturnNodeProp(ref _uLeft, value);
            }
            return null;
        }

        private Node ReturnNodeProp(ref Node Prop, Node value = null)
        {
            if (value == null)
            {
                return Prop;
            }
            else
            {
                Prop = value;
                return null;
            }
        }

        public Node this[int index]
        {
            get
            {
                return SwitchNodeProp(index);
            }
            set
            {
                SwitchNodeProp(index, value);
            }
        }

        public int Count
        {
            get
            {
                return _count;
            }
        }
        public bool isWall
        {
            get
            {
                return _isWall;
            }
            set
            {
                _isWall = value;
            }
        }
        public Node Left
        {
            get
            {
                return _left;
            }
            set
            {
                _left = value;
            }
        }
        public Node Right
        {
            get
            {
                return _right;
            }
            set
            {
                _right = value;
            }
        }
        public Node Up
        {
            get
            {
                return _up;
            }
            set
            {
                _up = value;
            }
        }
        public Node Down
        {
            get
            {
                return _down;
            }
            set
            {
                _down = value;
            }
        }
        public Node URight
        {
            get
            {
                return _uRight;
            }
            set
            {
                _uRight = value;
            }
        }
        public Node DRight
        {
            get
            {
                return _dRight;
            }
            set
            {
                _dRight = value;
            }
        }
        public Node ULeft
        {
            get
            {
                return _uLeft;
            }
            set
            {
                _uLeft = value;
            }
        }
        public Node DLeft
        {
            get
            {
                return _dLeft;
            }
            set
            {
                _dLeft = value;
            }
        }
        public int F
        {
            get
            {
                return _f;
            }
            set
            {
                _f = value;
            }
        }
        public int G
        {
            get
            {
                return _g;
            }
            set
            {
                _g = value;
            }
        }
        public int H
        {
            get
            {
                return _h;
            }
            set
            {
                _h = value;
            }
        }
        public Node Parent
        {
            get
            {
                return _parent;
            }
            set
            {
                _parent = value;
            }
        }
        public Point Pos
        {
            get
            {
                return _pos;
            }
            set
            {
                _pos = value;
            }
        }
    }
}

</pre>
<br />
每一个节点的相邻方格储存在相应的属性内<br />
<br />
并且可以直接以index 来获取：<br />
<br />
<a href="http://lh6.ggpht.com/-NniTQxuViBg/UnoNktSxP1I/AAAAAAAAFXs/h6aBrbRL3FU/s1600-h/image%25255B77%25255D.png"><img alt="image" border="0" height="213" src="http://lh6.ggpht.com/-zo15vf3fzBk/UnoNlCi_tZI/AAAAAAAAFX4/l3n8uFbD6B0/image_thumb%25255B25%25255D.png?imgmax=800" style="border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline;" title="image" width="310" /></a> <br />
<br />
<br />
<br />
这个是初始化一个二维Node 数组的代码：<br />
<pre class="brush: csharp">private void InitNodes(ref List&lt;List&lt;Node&gt;&gt; nodes)
{
    for (int x = 0; x &lt; _width; x++)
    {
        List&lt;Node&gt; nX = new List&lt;Node&gt;();
        for (int y = 0; y &lt; _height; y++)
        {
            Node nY = new Node();
            nY.Pos = new Point(x, y);
            //nY.F = x * 100 + y;
            //Up
            if (y &gt; 0)
            {
                nY.Up = nX[y - 1];
                nX[y - 1].Down = nY;
            }
            //Left
            if (x &gt; 0)
            {
                nY.Left = nodes[x - 1][y];
                nodes[x - 1][y].Right = nY;
            }
            //UpLeft
            if (x &gt; 0 &amp;&amp; y &gt; 0)
            {
                nY.ULeft = nodes[x - 1][y - 1];
                nodes[x - 1][y - 1].DRight = nY;
            }
            //DownLeft
            if (x &gt; 0 &amp;&amp; y &lt; (_height - 1))
            {
                nY.DLeft = nodes[x - 1][y + 1];
                nodes[x - 1][y + 1].URight = nY;
            }
            nX.Add(nY);
        }
        nodes.Add(nX);
    }
}
</pre>
<br />
<br />
<br />
<br />
这个是核心寻路算法：<br />
<pre class="brush: csharp">private void FindPath(ref List&lt;List&lt;Node&gt;&gt; nodes, Node start, Node end)
{
    List&lt;Node&gt; open = new List&lt;Node&gt;();
    List&lt;Node&gt; close = new List&lt;Node&gt;();

    open.Add(start);

    while (open.Count &gt; 0)
    {

        close.Add(open[0]); 
        Node pendingNode = open[0];
        open.RemoveAt(0);

        for (int i = 0; i &lt; pendingNode.Count; i++)
        {
            Node current = pendingNode[i];
            if (current == null || current.Equals(start) || current.isWall)
            {
                continue;
            }
            int h;
            int g;
            int f;

            if (i % 2 == 0)
            {
                //Up Right Down Left
                g = pendingNode.G + 10;
            }
            else
            {
                // URight DRight DLeft ULeft
                
                //check for walls
                //|X
                //|_
                if (pendingNode[(i + 1) % 8].isWall || pendingNode[i - 1].isWall)
                {
                    continue;
                }

                g = pendingNode.G + 14;
            }

            h = (Math.Abs(end.Pos.X - current.Pos.X) + Math.Abs(end.Pos.Y - current.Pos.Y)) * 10;
            f = h + g;
            if (f &lt; current.F || current.F == 0)
            {
                current.G = g;
                current.H = h;
                current.F = f;
                current.Parent = pendingNode;
                open.Add(current);
            }
            if (current.Equals(end))
            {
                List&lt;Node&gt; paths = new List&lt;Node&gt;();
                Node path = end;
                while (path.Parent != null)
                {
                    paths.Add(path);
                    path = path.Parent;
                }
                open.Clear();
                VisualizePath(paths);
                break;
            }                    
        }
        open = open.OrderBy(item =&gt; item.F).ToList();
    }

}
</pre>
<br />
<br />
注：这里没有实现“忽略已经在封闭列表中的节点”<br />
<br />
<br />
<br />
<h2>
【截图】</h2>
<br />
无图无真相，所以就发图：<br />
<br />
红色的是墙壁<br />
<br />
白色的是起始点<br />
<br />
蓝色的是终点<br />
<br />
<a href="http://lh4.ggpht.com/-uWTqTzkFwbY/UnoNl1O2QUI/AAAAAAAAFYA/TRerUg0SdXs/s1600-h/image%25255B83%25255D.png"><img alt="image" border="0" height="761" src="http://lh3.ggpht.com/-kqJIQY6ImUg/UnoNmfpXEHI/AAAAAAAAFYI/lfXp0fYV5Q4/image_thumb%25255B27%25255D.png?imgmax=800" style="border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline;" title="image" width="1024" /></a>